%% This is an example first chapter.  You should put chapter/appendix that you
%% write into a separate file, and add a line \include{yourfilename} to
%% main.tex, where `yourfilename.tex' is the name of the chapter/appendix file.
%% You can process specific files by typing their names in at the 
%% \files=
%% prompt when you run the file main.tex through LaTeX.
\chapter{Strict privacy notion}
\label{strict}
In this section I introduce a strong privacy definition where \textbf{all} voters are corrupted but an adversary is still unable to break privacy, denoted as strict privacy. I formally define strict voter privacy via a \textit{Strict Voter Privacy} game , denoted as $G_{strict,<honest~entities>}^{\mathcal{A}, Sim}(1^{\lambda})$,  that is played between an adversary A and a challenger C.\\

According to the game rules, an adversary is allowed to define the election parameters, corrupt some entities, and act on behalf of all voters.  $\mathcal{C}$ plays role of honest parties and returns to the adversary simulated and real view of a voter in order defined by a pre-flipped coin $a$ (If $a=0$, $\mathcal{C}$ returns $(simulated\_view,real\_view)$ and  $(real\_view,simulated\_view)$ otherwise). During the interaction with  $\mathcal{C}$,  $\mathcal{A}$ would try to guess the coin $a$. The \textit{Strict Voter Privacy} game takes as input the security parameter $\lambda$, the number of candidates m and the number of voters n, where $n,m$ are polynomial in $\lambda$, and returns 1 or 0 depending on whether the adversary wins or not.\\

The only difference between Strict privacy and Privacy is the number of corrupted voters. In Strict privacy games \textbf{all} voters are corrupted and  $\mathcal{A}$ vote on their behalf. On the contrary, in the Privacy games at most t voters are corrupted and all others are honest. The crucial moment is that honest voters are able to verify that their vote was cast as intended, but an adversary can not since he does not know the intent and does not control all entities. Therefore, voters may lie about vote while an adversary have no ways to learn the truth and not to win the game $G_{t-priv,<honest~entities>}^{\mathcal{A}, Sim}(1^{\lambda})$. \\

 The specification of trusted entities splits the Voter Privacy into different scenarios. All meaningful cases of collusion fall into two scenarios: (1) EA and T are hones and (2) VSD and T are honest. It is possible to construct e-voting scheme, that is private with respect to only trusted VSD, however most known schemes require trusted T as well. \\
 
I will show that the notion of strict privacy is the weakest level of privacy that contradicts end-to-end verifiability. To prove the contradiction I used the E2E verifiability definition given by Kiayias et al [1] and considered a strict voter privacy case where all voters are corrupted but an adversary is still unable to break privacy. Under this framework, I prove that it is not possible to achieve E2E verifiability in any strictly private system. Moreover, any meaningful relaxation of the strict privacy definition, leads to a notion if privacy that is feasible by some E2E verifiable e-voting system.

\section{$\ea$ and $T$ are honest: $G_{strict,\ea,T}^{\mathcal{A}, Sim}(1^{\lambda})$}
\textit{Strict Voter Privacy} implies that even if all voters are corrupted,   an adversary $\mathcal{A}$ is still unable to break the individual privacy and learn the actual votes. The \textit{Strict Voter Privacy}  game is similar to the \textit{Voter Privacy} game, but instead of scheduling the \textbf{Registration} protocol for a voter $V$,  $\mathcal{A}$ starts the protocol itself. \\

In the game  $G_{strict,\ea,T}^{\mathcal{A}, Sim}(1^{\lambda})$ , an adversary $\mathcal{A}$ interacts with the challenger $\mathcal{C}$ on behalf of \textbf{all} voters, $\voc$ and $\vsd$. $\mathcal{C}$ plays the role of $\ea$ and $T$. $\bb$ is completely passive and represents a publicly viewed database. \\

  \begin{figure}[h!]
 \includestandalone[mode=buildnew]{figures/figure6}
        \caption{$G_{strict,\ea,T}^{\mathcal{A}, Sim}(1^{\lambda})$}
        \label{EAT is honest}
\end{figure}
1)  $\mathcal{A}$ picks and sends two options $U_i^0,U_i^1$ to the challenger $\mathcal{C}$. The first option $U_i^0$ is its intent, the other -- the option that the challenger would use in order to produce an indistinguishable from the intent's ballot and receipt view*. 2) After sending options, $\mathcal{A}$ runs the   \textbf{Registration} protocol with $\mathcal{C}$ on behalf of some voter $V_i$. 3) $\mathcal{C}$ creates a fake credentials $\tilde{s_i}$ and generates real credentials $s_i$ for the voter $V_i$. 4) $\mathcal{C}$ responds $\mathcal{A}$ with a pair of credentials $s_i^0,s_i^1$, where one of the credentials are real and the other were generated using the simulator $Sim$ in a such way, that if $\mathcal{A}$ guesses right and uses the real credentials to cast a vote for $U_i^0$, the produced ballot and internal view of the \textbf{Cast} protocol would be real, otherwise generated ballot would correspond to the option $U_i^1$ and the returned view would be fake. 5) If $\mathcal{A}$ choses to post the ballot $b_i$ to $\bb$, 6) $\mathcal{C}$ posts exactly the same ballot** to $\bb$. 7) When $\mathcal{A}$ stops the election, $\mathcal{C}$ posts the tally $\tau$ ***. \\\\
Remarks:\\
*If  $\mathcal{C}$ succeeds, $\mathcal{A}$ wouldn't be able to say whether it voted for option $U_i^0$ or $U_i^0$ and $\bb$ would contain both ballots (one for the option $U_i^0$ ,the other for the option $U_i^1$) so the tally wouldn't reveal any information. Example: if $\mathcal{A}$  picks real credential then it casts a vote for the option  $U_i^0$ on behalf of a voter $V_i$, at the same time exactly the same ballot posted by $\mathcal{C}$ would correspond to the fake credentials and the option $U_i^1$. In this case $\mathcal{A}$ indeed voted for $U_{i_1}$ as it intended. Else if $\mathcal{A}$ picks the fake credentials and votes for the option $U_i^0$,  its ballot corresponds to the real credentials and  the option $U_i^1$. At the same time, exactly the same ballot posted by $\mathcal{C}$ corresponds to the fake credentials  and the option $U_i^0$. So $\mathcal{A}$  voted for $U_i^0$. If this privacy holds,  $\mathcal{A}$ has no idea what option voter $V_i$ voted for. \\\\
** $\mathcal{C}$ should post to the $\bb$ a ballot for the remaining candidate. If  $\mathcal{A}$  voted for $U_i^0$, $\mathcal{C}$ should vote for the $U_i^1$ and vice versa. Otherwise  $\mathcal{A}$  would guess the coin $a$ by simply checking the result of an election.  $\mathcal{A}$ is allowed to pick any two options $U_i^0,U_i^1$  and play as many rounds as it likes. Since lists $\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} $ and  $\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} $  not necessarily  sums to  the same result as lists  $\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} $ and  $\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} $, where $ \tilde{\mathcal{V}}^0$ is a list of voter for which $\mathcal{A}$ choses to post produced ballot and used credentials $s_i^0$ and $ \tilde{\mathcal{V}}^0$ similar but instead credentials $s_i^1$ were used, the adversary would trivially break privacy. To prevent it, the challenger's ballots are added to the $\bb$ and compute the combined tally, namely $f(\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} ) + f(\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} )+ f(\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} ) +  f(\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} )$. However, if lists $\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^0}, \langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^1}$ and $\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^0}, \langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^1}$ sums to the same result $f(\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} ) + f(\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} ) =  f(\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} ) +  f(\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} )$, the challenger's ballots are removed and the actual tally is computed. \\\\
*** The tally $\tau$ is posted only if for every correctly formed adversarial ballot, there is a corresponding challenger's ballot posted on the $\bb$. $\mathcal{A}$ may not post some ballots, however if it does, then challenger's ballot must be posted as well. Otherwise, $\mathcal{A}$ wins the \textit{Voter Privacy} game by simply checking the announced result.  All $\mathcal{A}$'s ballots are tallied based on real credentials, all  $\mathcal{C}$'s ones -- based on fake credentials. Denote the list of voter for which $\mathcal{A}$ choses to post produced ballot and uses credentials $s_i^0$  as $ \tilde{\mathcal{V}}^0$ and the similar list but for credentials $s_i^1$ as $ \tilde{\mathcal{V}}^0$.   $\mathcal{C}$ removes all challenger's ballots and computes tally for the adversarial ballots only if and only if  lists $\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^0}, \langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^1}$ and $\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^0}, \langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^1}$ sums to the same result $f(\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} ) + f(\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} ) =  f(\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} ) +  f(\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} )$. In this case, the result would be $f(\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} ) + f(\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} )$ if challenger's coin $a=0$ or  $f(\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} ) +  f(\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} )$ otherwise.\\

$G_{strict,\ea,T}^{\mathcal{A}, Sim}(1^{\lambda},n,m)$ defined as follows:\\
\begin{enumerate}
\item $\mathcal{A}$ on input $1^{\lambda},n,m$ defines a set of voters  $\mathcal{V} = \{V_1,...,V_n\}$, choses a list of candidates  $\mathcal{P} = \{P_1,...,P_m\}$ and the set of allowed candidates' selections $\mathcal{U}$.  It provides $\mathcal{C}$ with $\mathcal{V}, \mathcal{P}, \mathcal{U}$.
\item $\mathcal{C}$ flips a coin $a \leftarrow \{0,1\}$ to define an order according to which real and simulated credentials would be returned to $\mathcal{A}$, and starts the election on behalf of $\ea$. 
\item The adversary $\mathcal{A}$ picks two option $U^0_i,U^1_i \in \mathcal{U}$, where $U^0_i$ is its intent and $U^1_i$ is an option that $\mathcal{C}$ would use in order to fool $\mathcal{A}$. After that, $\mathcal{A}$  and $\mathcal{C}$ engage in an interaction where $\mathcal{A}$ runs the \textbf{Registration} protocols on behalf of all voters. For each voter $V_i \in \mathcal{V}$:
\begin{enumerate}
\item[] --  $\mathcal{C}$ generates real credentials $s_i$  and fake credentials $\tilde{s_i}$ using $Sim$.  $\mathcal{C}$  responds  $\mathcal{A}$ with a pair of simulated and real credentials $(s_0,s_1)$ in order defined by the coin a:
$ \begin{cases}
 \text{if} ~~a =0,~~ (s^0_i,s^1_i) = (\tilde{s_i},s_i)  \\ 
 \text{else}~~  (s^0_i,s^1_i) = (s_i,\tilde{s_i})
\end{cases}$
\item[] -- Using one of the credentials $\mathcal{A}$ schedules the \textbf{Cast} protocol execution to vote for an option $U^0_i$ and sends the produced ballot to $\bb$. As a result of the \textbf{Cast} protocol execution, $\mathcal{A}$ would obtain: receipt $r_i$, ballot $b_i$ and the view of the internal state of the voter $V_i$ -- $view_i$.  During the \textbf{Tally} protocol execution this ballot would be treated as if it was generated with real credentials $s_i$. So, if  $\mathcal{A}$ indeed picked the real credentials, $b_i$ would correspond to the option   $U^0_i$  and $view_i$ would be real. Otherwise, $b_i$ would be a ballot for the option  $U^1_i$ and $view_i$ would be fake. 
\item[] --  If  $\mathcal{A}$ posts a ballot on $\bb$, $\mathcal{C}$ posts exactly the same ballot. During the \textbf{Tally} protocol execution this ballot would be treated as if it was generated with fake credentials, which means that whatever option in reality $\mathcal{A}$ voted for, $\mathcal{C}$ picked the other option.  
\end{enumerate}
\item Denote the list of voter for which $\mathcal{A}$ choses to post produced ballot and uses credentials $s_i^0$  as $ \tilde{\mathcal{V}}^0$ and the similar list but for credentials $s_i^1$ as $ \tilde{\mathcal{V}}^0$.  If  lists $\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^0}, \langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^1}$ and $\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^0}, \langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^1}$ sums to the same result $f(\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} ) + f(\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} ) =  f(\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} ) +  f(\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} )$, $\mathcal{C}$ removes all challenger's ballots and executes the \textbf{Tally} protocol on the cleared $\bb$. Otherwise, $\mathcal{C}$ executes the \textbf{Tally} protocol on the $\bb$ that contains adversarial and challenger's ballots. 
\item Finally, $\mathcal{A}$ using all information collected above (including the contents of the BB) outputs a bit $a^*$
\item  The game returns a bit which is 1 if $a = a^*$ and 0 otherwise.
\end{enumerate}


\textbf{Remark:}\\
$Sim$ works in such a way that fake credentials satisfy both of the following rules: 
\begin{enumerate}
 \item The real credentials and $U_i^0$ option  should give ballot and receipt, which are identical indistinguishable from ballot and receipt produced for the fake credentials and  $U_i^1$ option.
 \item The fake credentials and $U_i^0$ option  should give ballot and receipt, which are identical to ballot and receipt produced for the real credentials and  $U_i^1$ option.
 \end{enumerate}
 
\underline{\textbf{Strict privacy: $\ea$ and $T$ are honest:}}\\\\
The e-voting system $\Pi$ achieves strict voter privacy in case of trusted $\ea$ and $T$, if there is a PPT simulator $Sim$ such that for any PPT adversary $\mathcal{A}$:\\\\
 $|\Pr[G_{strict,\ea,T}^{\mathcal{A}, Sim}(1^{\lambda},n,m) = 1]- \frac{1}{2} |= negl(\lambda)$
 
\section{$\vsd$ and $T$ are honest: $G_{strict,\vsd}^{\mathcal{A},Sim}(1^{\lambda},n,m)$}
  \begin{figure}[h!]
 \includestandalone[mode=buildnew]{figures/figure7}
        \caption{ $G_{strict,\vsd}^{\mathcal{A},Sim}(1^{\lambda})$}
        \label{VSD is honest}
\end{figure}
%This case is meaningful for e-voting, only if there exists some entity, let us call it a trustee $T$, which must participate in the $Tally$ protocol for an election transcript to be produced. If there is no such trusted entity, than an adversary, who corrupts $\ea$, has all necessary information for breaking everyone's privacy. It happens due to the following e-voting assumption: voters are not expected to collaborate in order to preserve privacy or integrity of an election. \\\\
%The following definition of strict privacy applies only to cases where $\ea$ is corrupted, $\vsd$ is honest and there is at least one trusted entity, which must participate in the $Tally$ protocol for producing an election tally. \\\\

In \textit{Strict Voter Privacy} game I do not consider the case where privacy of voters relies on trusted $\vsd$ \textbf{only} since the case is rather extreme and rare. The definition of strict voter privacy below is given for trusted $\vsd$ and $T$. However, I identify changes that would transform the given definition into \textbf{only} $\vsd$ is trusted case.\\

 In the game $G_{strict,\vsd,T}^{\mathcal{A}, Sim}(1^{\lambda},n,m)$ there is no honest voters, instead an adversary $\mathcal{A}$ operates on behalf of the all voters , $\ea$ and $\voc$.  $\mathcal{C}$ plays on behalf of $\vsd$ and $T$.  $\bb$ is completely passive and represents a publicly accessible database.\\
 
 1)  $\mathcal{A}$ picks and sends options $U_i^0, U_i^1$ to the challenger $\mathcal{C}$. 2) After that $\mathcal{A}$ runs the \textbf{Cast} protocol with $\mathcal{C}$. 3) $\mathcal{C}$ generates a real ballot, receipt and view for an option $U_i^0$ and uses $Sim$ and option $U_i^1$ to create the fake ones.  4) At the end $\mathcal{C}$ responses with a pair of ballots, receipts and view $b_i^0,r_i^0,view_i^0,b_i^1,r_i^1,view_i^1$, where the order of real and fake output is determined according a coin $a$. 5) If $\mathcal{A}$ posts a ballots on the $\bb$, $\mathcal{C}$ posts the other ballot*. 6)  When $\mathcal{A}$ stops the election, $\mathcal{C}$ posts the tally $\tau$ ** \\

*$\mathcal{C}$ should post to the $\bb$ the remaining ballot, otherwise  $\mathcal{A}$  would guess the coin $a$ by simply checking the result of an election. $\mathcal{A}$ is allowed to pick any two options $U_i^0,U_i^1$  and play as many rounds as it likes. Since lists $\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} $ and  $\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} $  not necessarily  sums to  the same result as lists  $\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} $ and  $\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} $, where $ \tilde{\mathcal{V}}^0$ is a list of honest voter for which $\mathcal{A}$ choses to post produced ballot and used credentials $s_i^0$ and $ \tilde{\mathcal{V}}^0$ similar but instead credentials $s_i^1$ were used, the adversary would trivially break privacy. To prevent it, the challenger's ballots  are added to the $\bb$ and compute the combined tally, namely $f(\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} ) + f(\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} )+ f(\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} ) +  f(\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} )$. However, if lists $\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^0}, \langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^1}$ and $\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^0}, \langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^1}$ sums to the same result $f(\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} ) + f(\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} ) =  f(\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} ) +  f(\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} )$, the challenger's ballots are removed and  the actual tally is computed. \\\\
*** The tally $\tau$ is posted only if for every correctly formed adversarial ballot, there is a corresponding challenger's ballot posted on the $\bb$. $\mathcal{A}$ may not post some ballots, however if it does, then challenger's ballot must be posted as well. Otherwise, $\mathcal{A}$ wins the \textit{Voter Privacy} game by simply checking the announced result.  All $\mathcal{A}$'s ballots are tallied based on real credentials, all  $\mathcal{C}$'s ones -- based on fake credentials. Denote the list of  voter for which $\mathcal{A}$ choses to post produced ballot and uses credentials $s_i^0$  as $ \tilde{\mathcal{V}}^0$ and the similar list but for credentials $s_i^1$ as $ \tilde{\mathcal{V}}^0$.   $\mathcal{C}$ removes all challenger's ballots and computes tally for the adversarial ballots only if and only if  lists $\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^0}, \langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^1}$ and $\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^0}, \langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^1}$ sums to the same result $f(\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} ) + f(\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} ) =  f(\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} ) +  f(\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} )$. In this case, the result would be $f(\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} ) + f(\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} )$ if challenger's coin $a=0$ or  $f(\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} ) +  f(\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} )$ otherwise.\\

The game $G_{strict, \vsd}^{\mathcal{A},Sim}(1^{\lambda})$ is defined as follows:
\begin{enumerate} 
\item $\mathcal{A}$ on input $1^{\lambda},n,m$ defines a set of voters  $\mathcal{V} = \{V_1,...,V_n\}$, choses a list of candidates  $\mathcal{P} = \{P_1,...,P_m\}$ and the set of allowed candidates' selections $\mathcal{U}$.  $\mathcal{A}$ starts an election using $\mathcal{V}, \mathcal{P}, \mathcal{U}$ as input parameters.
\item $\mathcal{C}$ flips a coin $a \leftarrow \{0,1\}$ to define an order according to which real and simulated ballots and receipts would be returned to $\mathcal{A}$.
\item   $\mathcal{A}$ sends to  $\mathcal{C}$ options $U_i^0, U_i^1 \in  \mathcal{U}$, where $U_i^0$ is an option for the real ballot and receipt and $U_i^1$ is an option for the fake ones.  After that, $\mathcal{A}$ and $\mathcal{C}$ engage in an interaction where $\mathcal{A}$ runs the \textbf{Cast} protocols of all voters which may run concurrently. For each voter $V_i \in \mathcal{V}$: 
\begin{enumerate}
\item[] -- $\mathcal{C}$  provides $\mathcal{A}$ with a pair of simulated and real ballot,receipt and view $(b_i^0, r_i^0,view_i^0) (b_i^1, r_i^1,view_i^1)$ s.t.:\\
$ \begin{cases}
 \text{if} ~~a =0,~~ (b_i^0,r_i^0,view_i^0) = (\tilde{b_i},\tilde{r_i},fake\_view_i) ~~ \text{and} ~~  (b_i^1,r_i^1,view_i^1) = (b_i,r_i,view_i)   \\ 
 \text{else}~~ (b_i^0,r_i^0,view_i) =(b_i,r_i,view_i)~~  \text{and} ~~  (b_i^1,r_i^1,view_i^1) =(\tilde{b_i},\tilde{r_i},fake\_view_i)
\end{cases}$\\ 
where the pair $(b_i, r_i)$ is the ballot and receipt for an adversarial option $U_i^0$ and $(\tilde{b_i},\tilde{r_i})$ is the ballot and receipt for  $U_i^1$ option generated via the simulator $Sim$.
\item[] --  If  $\mathcal{A}$ posts a ballot on $\bb$, $\mathcal{C}$ posts the remaining ballot. 
\end{enumerate}
\item Denote the list of voter for which $\mathcal{A}$ choses to post produced ballot and uses credentials $s_i^0$  as $ \tilde{\mathcal{V}}^0$ and the similar list but for credentials $s_i^1$ as $ \tilde{\mathcal{V}}^0$.  If  lists $\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^0}, \langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^1}$ and $\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^0}, \langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^1}$ sums to the same result $f(\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} ) + f(\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} ) =  f(\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} ) +  f(\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} )$, $\mathcal{C}$ removes all challenger's ballots and executes the \textbf{Tally} protocol on the cleared $\bb$. Otherwise, $\mathcal{C}$ executes the \textbf{Tally} protocol on the $\bb$ that contains ballots for both options $U_i^0$ and $U_i^1$. 
\item Finally, $\mathcal{A}$ using all information collected above (including the contents of the BB) outputs a bit $a^*$
\item The game returns a bit which is 1 if $a = a^*$ and 0 otherwise
\end{enumerate}
\textbf{*Remark:}\\
$\mathcal{A}$ can control $T$ and perform \textbf{Tally} procedure. However, in such a case, it should be impossible for $T$ to learn the underline vote for any individual ballot or compute the result for $\bb$ that does not contain all ballots $b_i^0,b_i^1$. The only exception is the case when lists  $\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} $ and  $\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} $ sums up to the same tally as lists  $\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}^1} $ and  $\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}^0} $, for this situation $\mathcal{A}$ may perform \textbf{Tally} operation without challenger's ballots. \\\\

\underline{\textbf{Strict privacy: $\vsd$ is honest:}}\\\\
The e-voting system $\Pi$ achieves strict voter privacy in case when $\vsd$ is trusted, if there is a PPT simulator $Sim$ such that for any PPT adversary $\mathcal{A}$:\\\\
 $|\Pr[G_{strict,\vsd}^{\mathcal{A},Sim}(1^{\lambda},n,m) = 1] - \frac{1}{2}| = negl(\lambda)$\\\\
 
 Because \textit{Demos Privacy} implies the weaker security than \textit{Voter Privacy}, the same holds for strict privacy notion. I introduce \textit{Strict Version of Demos Privacy}, where $\mathcal{A}$ does not corrupt any entity, but operates on behalf of all voters. \\
   
 \textbf{Strict version of Demos Privacy}\\
 $G_{DEMOS,strict}^{*\mathcal{A}, \mathcal{S}}(1^{\lambda},n,m)$ defined as follows:\\
\begin{enumerate}
\item $\mathcal{A}$ on input $1^{\lambda},n,m$ defines a set of voters  $\mathcal{V} = \{V_1,...,V_n\}$, choses a list of candidates  $\mathcal{P} = \{P_1,...,P_m\}$ and the set of allowed candidates' selections $\mathcal{U}$.  It provides $\mathcal{C}$ with $\mathcal{V}, \mathcal{P}, \mathcal{U}$.
\item $\mathcal{C}$ flips a coin $b\in \{0,1\}$ and perform the \textbf{Setup} protocol on input $1^{\lambda},\mathcal{V}, \mathcal{P}, \mathcal{U}$ to obtain $msk,s_1,...,s_n, Pub$; it provides  $\mathcal{A}$ with $Pub$. 
\item The adversary $\mathcal{A}$  and $\mathcal{C}$ engage in an interaction where $\mathcal{A}$ runs the \textbf{Cast} protocols on behalf of all voters:
\begin{enumerate}
\item[] --  $\mathcal{A}$ provides two candidates selections $\langle \mathcal{U}^0_l , \mathcal{U}^1_l \rangle$ to the challenger $\mathcal{C}$ and plays on behalf $V_i$. $\mathcal{C}$ uses $\mathcal{U}^b_l$ as the $V_i$'s input. When the  \textbf{Cast} protocol terminates, the challenger  $\mathcal{C}$ provides to $\mathcal{A}$: (i) the receipt $\alpha_l$ and (ii) if b = 0, the real view of internal state of the voter $V_l$, $view_l$ obtained from the \textbf{Cast} protocol execution; or  a simulated view of the internal state of $V_l$ produced by $\mathcal{S}(view_l)$.
\end{enumerate}
\item $\mathcal{C}$ performs the  \textbf{Tally} protocol playing the role of $\ea$, $T$  and $\bb$. $\mathcal{A}$ is allowed to observe the network trace of that protocol. 
\item Finally, $\mathcal{A}$ using all information collected above (including the contents of the BB) outputs a bit $b^*$
\item  The game returns a bit which is 1 if both conditions are true: 1) $b = b^*$ and 2) $f(\langle \mathcal{U}^1_i \rangle _{V_i \in \tilde{\mathcal{V}}} ) =  f(\langle \mathcal{U}^0_i \rangle _{V_i \in \tilde{\mathcal{V}}} )$ and 0 otherwise
\end{enumerate}

\underline{\textbf{Strict Demos Privacy :}}\\\\
The e-voting system $\Pi$ achieves strict demos voter privacy, if there is a PPT simulator $Sim$ such that for any PPT adversary $\mathcal{A}$:\\\\
 $|\Pr[G_{DEMOS,strict}^{*\mathcal{A},Sim}(1^{\lambda},n,m) = 1] - \frac{1}{2}| = negl(\lambda)$\\\\
 %
%=============================================================================================================
%
\section{Strict privacy vs E2E Verifiability}
The Universal Composability (UC) is a framework for representing cryptographic protocols and analyzing their security \cite{Canetti2001}. UC provides very  strong security guarantees and allows to specify security requirements in a unified and systematic way. There are just tree entities involved: a protocol, an adversary and an environment that captures everything else that goes beyond the protocol execution. The best explanation what does UC mean is given by Jens Groth: "In the UC framework, an execution of a multi-party computation protocol is compared to an execution where a trusted ideal functionality handles the data and produces the output. A protocol is said to be secure if an adversary operating in a real-life model can be simulated in the ideal process model with the ideal functionality. In the case of voting, the ideal functionality takes as input the votes and outputs the result of the election. This ideal functionality corresponds to the old method of voters marking their choice on paper and putting the ballot in a box, which is opened once the election is over."\cite{Groth2004}.\\

Originally UC considers the execution of an unbounded number of concurrent protocols in the arbitrary environment, controlled by an adversary. Even though UC seems to be the most realistic level of security, it cannot be achieved in general without some trusted setup assumptions \cite{Lin2009}. The stand-alone setting on the other hand only allows the execution of a single instance of the protocol at a time and guarantees the security under sequential composition, namely if a protocol is secure in stand-along model it maintains its security in sequential runs, where each execution concludes before the next one begins.  Sequential composition does not imply security in the concurrent composition, however it provides reasonably high security guarantees.\\ 

In stand-alone model an adversary is restricted from communicating with the environment during the protocol execution. Stand-alone model enables one to design a protocol using calls to an ideal functionality, which is secure by design,  and check whether a real protocol properly implements this ideal protocol. This makes security analysis significantly more simple. A protocol is said to be secure if for all adversaries, there exists a simulator, so that real and ideal executions are indistinguishable for and any environment \cite{Lindell2016}. \\

In this section I prove that "Any system $\Pi$ that satisfies the definition of strict privacy, is "receipt free" but not E2E Verifiable".\\

The Real and Ideal executions in this case are shown on the figure 6.
 \begin{figure}
\begin{tikzpicture}
    \node (s) [a] {$\mathcal{A}$};
    \path (s.east)+(1.5*\blockdist,3) node (g) [sensor] {$\mathcal{G}_{BB}$};
    \path (s.east)+(1.5*\blockdist,0) node (system) [s] {$\Pi$};
    \path (system.east) +(0.7*\blockdist,-2) node (v0) [v] {$V_0$};
    \path (system.east) +(0.7*\blockdist,-1) node (v1) [v] {$V_1$};
     \path (system.east) +(0.7*\blockdist, 0) node (vn) [v] {$V_n$};
     \path (s.west) +(0.95*\blockdist,-1.1) node (v0') [vv] {$V_0'$};
      \path (s.west) +(0.95*\blockdist,0) node (v1') [vv] {$V_1'$};
       \path (s.west) +(0.95*\blockdist,1.1) node (vn') [vv] {$V_n'$};
    \path (s.east) +(\blockdist, -2) node (RE) {Real Execution};
    \draw[transform canvas={yshift=0.7ex},->] (system) -- (s);
    \draw[transform canvas={yshift=-0.7ex},<-] (system) -- (s);
    \draw[transform canvas={xshift=0.7ex},->] (system) -- (g);
    \draw[transform canvas={xshift=-0.7ex},<-] (system) -- (g);
     \path [draw, <-] (system) --  (v1.west);
      \path [draw, <-] (system) -- (v0.west);
      \path [draw, <-] (system) --  (vn.west);
    \draw [<-] (v0.-40)-- node [ann] {} + (\edgedist,0) 
        node[right] {$U_0$};
      \draw [<-] (v1.-40)-- node [ann] {} + (\edgedist,0) 
        node[right] {$U_1$};
     \draw [<-] (vn.-40)-- node [ann] {} + (\edgedist,0) 
        node[right] {$U_n$};
     \draw [->] (v0.40)-- node [ann] {} + (\edgedist,0) 
        node[right] {$response_0$};
      \draw [->] (v1.40)-- node [ann] {} + (\edgedist,0) 
        node[right] {$response_1$};
     \draw [->] (vn.40)-- node [ann] {} + (\edgedist,0) 
        node[right] {$response_n$};
        \draw [<-] (system.15) -- node [ann] {} + (\edgedist,1) 
        node[right] {$election\_params$};
    \begin{pgfonlayer}{background}
        \path (s.west |- g.north)+(-0.5,0.3) node (a) {};
        \path (v0.south -| v0.east)+(+0.3,-0.2) node (b) {};
        \path[rounded corners, draw=black, dashed]
            (a) rectangle (b);
    \end{pgfonlayer}
\end{tikzpicture}
\begin{tikzpicture}
    \node (s) [a] {$\mathcal{F}$};
    \path (s.east)+(1.5*\blockdist,3) node (g) [sensor] {$\mathcal{G}_{BB}$};
    \path (s.east)+(1.5*\blockdist,0) node (system) [sim] {};
    \path (s.east)+(1.1*\blockdist,0) node (adv) [sensor] {$\mathcal{A}$};
     \path (s.east)+(1.9*\blockdist,0) node (ss) [sensor] {$\Pi$};
    \path (ss.east) +(0.7*\blockdist,-4) node (v0) [v] {$V_0$};
    \path (ss.east) +(0.7*\blockdist,-3) node (v1) [v] {$V_1$};
     \path (ss.east) +(0.7*\blockdist, -2) node (vn) [v] {$V_n$};
    \path (s.east) +(\blockdist, -5) node (RE) {Ideal Execution};
     \path (s.east) +(1.5*\blockdist, -1) node (ssimulator) {$\mathcal{S}$};
    \draw[transform canvas={yshift=0.7ex},->] (system) -- (s);
    \draw[transform canvas={yshift=-0.7ex},<-] (system) -- (s);
    \draw[transform canvas={xshift=0.7ex},->] (system) -- (g);
    \draw[transform canvas={xshift=-0.7ex},<-] (system) -- (g);
    \draw[transform canvas={yshift=0.7ex},->] (ss) -- (adv);
    \draw[transform canvas={yshift=-0.7ex},<-] (ss) -- (adv);
     \path [draw, <-] (s) |-  (v1.west);
      \path [draw, <-] (s) |- (v0.west);
      \path [draw, <-] (s) |-  (vn.west);
    \draw [<-] (v0.-40)-- node [ann] {} + (\edgedist,0) 
        node[right] {$U_0$};
      \draw [<-] (v1.-40)-- node [ann] {} + (\edgedist,0) 
        node[right] {$U_1$};
     \draw [<-] (vn.-40)-- node [ann] {} + (\edgedist,0) 
        node[right] {$U_n$};
     \draw [->] (v0.40)-- node [ann] {} + (\edgedist,0) 
        node[right] {$response_0$};
      \draw [->] (v1.40)-- node [ann] {} + (\edgedist,0) 
        node[right] {$response_1$};
     \draw [->] (vn.40)-- node [ann] {} + (\edgedist,0) 
        node[right] {$response_n$};
        \draw [<-] (system.20)-- node [ann] {} + (\edgedist,0) 
        node[right] {$election\_params$};
    \begin{pgfonlayer}{background}
        \path (s.west |- g.north)+(-0.5,0.3) node (a) {};
        \path (RE.south -| v0.east)+(+0.3,-0.2) node (b) {};
        \path[rounded corners, draw=black, dashed]
            (a) rectangle (b);
    \end{pgfonlayer}
\end{tikzpicture}
        \caption{Real and Ideal Execution}
        \label{ RI}
\end{figure}\\
Security requires existence of some simulator program $\mathcal{S}$ such that the real and ideal executions are indistinguishable for and any environment  $\mathcal{Z}$. Unfortunately, as I am about to show, no such simulator exists.\\\\
\textbf{Theorem:}\\ 
For any system $\Pi$ that satisfies the definition of strict privacy, there is an adversary $\mathcal{A}$  such that for any simulator $\mathcal{S}$, there is an environment $\mathcal{Z}$ that distinguishes ideal and real executions $\exec_{\mathcal{Z}, \mathcal{S}}^{\mathcal{F}, \mathcal{G}_{BB}} \not \approx \exec_{\mathcal{Z},\mathcal{A}}^{\Pi, \mathcal{G}_{BB}}$ \\\\

\section{Proof part 1: E2E Verifiability vs Strict privacy with respect to $\ea$ and $T$.}
Suppose there is a system $\Pi$, which is strictly private in case ``$\ea$ is corrupted, but $\vsd$ and $T$ are honest".\\
Consider the following attack against E2E Verifiability: \\
\fbox{\begin{minipage}{30em}
$\mathcal{A}$:\\
-- corrupts $\ea$ and $\vsd$s but doesn't corrupt $\asd$s.\\
-- corrupts $t$ voters $(t \leq n)$ , where $n$ is the total number of voters.\\ 
-- creates fake voters $\{V_0',V_1',\dots,V_n'\}$ and using its power substitutes some part $\gamma$ of honest voters with fake ones for the $U_a$ option.\\
-- fake voters vote for adversarial options according to a vote-casting procedure.\\
-- substituted honest voters receive receipts generated for fake voters.
\end{minipage}}\\\\
  \begin{figure}[h!]
 \includestandalone[mode=buildnew]{figures/attack}
        \caption{  $\mathcal{A}$}
\end{figure}\\
let $\mathcal{Z}$ be the environment that works as follows:\\\\
\fbox{\begin{minipage}{30em}
$\mathcal{Z}$:\\
--  defines an election setup information:\\ $election\_params = (\mathcal{C},\mathcal{V}, \mathcal{U}, params)$, where $\mathcal{C}$ - list of candidates, $\mathcal{V}$ - list of voters, $\mathcal{U}$ - list of allowed candidates' selections, $params$ - other required information.\\
-- instructs each voter $V_i$ to vote for the blank $'no~one'$ option.\\
-- stops the vote-casting phase.\\
-- asks $\mathcal{G}_{BB}$ for the election result $\tau$\\
--  asks every voter $V_i$ to verify his choice and return the result of verification - $response_i$, where $response_i$ equal to $(sid, verify\_responce, \tau')$  in case of successful verification and $\bot$ otherwise.\\
-- If the number of successful verification responses equal to the number of voters and in all responses provided by a voter tally $\tau'$ is equal to the $\mathcal{G}_{BB}$'s tally $\tau$ return 1. Otherwise return 0.
\end{minipage}}
\\\\
 Since $\Pi$ is strictly private, probability, that an adversary $\mathcal{D}$ engaging in the \textbf{Cast} protocol would distinguish real and simulated view and win the attack against the strict privacy $Pr[G_{strict,\vsd,T}^{\mathcal{D},Sim}(1^{\lambda,n,m}) = 1] = \frac{1}{2} + \alpha$ where $\alpha$ is negligible. In case of corrupted $\ea$, $\mathcal{C}$ returns a real pair of ballot and receipt and a real view and also a simulated via $Sim$ pair and fake view. This means that in a strictly private system an adversary has a negligible chance to distinguish the ballot and receipt for his option and for some $U_a$ option. \\\\
During the Real Execution a voter can either accept or reject the cast ballot. Rejection is possible only if he detects that the returned receipt, ballot and view are faked. The probability that a voter distinguish the receipt and ballot for his option from for the `no-one' option and rejects is $\Pr[V_i~rejects] \leq  \alpha$, where $\alpha$ is negligible.\\\\
 By nature of the attack,  fake receipt is the perfectly valid receipt for the $U_a$ option and the cast ballot would always be successfully verified. Therefore in the Real Execution $\mathcal{Z}$ would get a successful verification response from all n voters and output 1 with the probability $\Pr[\exec_{\mathcal{Z},\mathcal{A}}^{\Pi, \mathcal{G}_{BB}} = 1] =  \Pr[all~V_i~accept] = \prod_{i=0}^n(1- \Pr[V_i~rejects] ) \geq (1 - \alpha)^n = 1 - n\alpha = 1- \beta$, where $\beta = n\alpha $ is negligible. Thus, $\Pr[\exec_{\mathcal{Z},\mathcal{A}}^{\Pi, \mathcal{G}_{BB}} = 0] = 1 - \Pr[\exec_{\mathcal{Z},\mathcal{A}}^{\Pi, \mathcal{G}_{BB}} = 1] \leq \beta$, where $\beta$ is negligible.\\\\
Suppose for the sake of contradiction that $\Pr[\exec_{\mathcal{Z},\mathcal{A}}^{\Pi, \mathcal{G}_{BB}} = 0] \geq  \beta$, where $\beta$ is non-negligible. This means that at least one voter rejects the receipt. I will show that this contradicts the definition of strict privacy. Consider an attacker $\mathcal{B}$ against strict privacy which exploits the environment  $\mathcal{Z}$. \\\\
\begin{tikzpicture}
    \node (s) [a] {$\mathcal{C}$};
    \path (s.east)+(1.5*\blockdist,0) node (system) [draw, text width=8em, 
    text centered, minimum height=8em] {};
    \path (s.east)+(1.1*\blockdist,1) node (adv) [sensor] {$\ea$};
     \path (s.east)+(1.1*\blockdist,-0.5) node (ss) [sensor] {$\mathcal{Z}$};
     \path (s.east) +(1.5*\blockdist, -1.3) node (ssimulator) {$\mathcal{B}$};
    \draw[transform canvas={yshift=0.7ex},->] (system) -- (s);
    \draw[transform canvas={yshift=-0.7ex},<-] (system) -- (s);
\end{tikzpicture}

\fbox{\begin{minipage}{30em}
$\mathcal{B}$ interacts with the challenger in the strict privacy attack  $\mathcal{C}$ as follows: \\
-- $\mathcal{Z}$ defines an election parameters  $election\_params$, assign every voter to vote for the blank option $\{V_i,`no~one'\}$ and send this information to the $\mathcal{B}$.\\
-- $\mathcal{B}$ forwards received $election\_params$ to the $\ea$. \\
-- $\mathcal{B}$ corrupts the $\ea$.\\
-- $\ea$ starts the election.\\
-- $\mathcal{B}$ interacts with the challenger $\mathcal{C}$ provides  $(V_i,`no~one',U_{\mathcal{Z}_i})$ as the input.\\ 
--  $\mathcal{C}$ sends back to the $\mathcal{B}$ real and simulated view $(b_0,r_0), (b_1,r_1)$ in the order defined by the challenger's coin a. \\
-- $\mathcal{B}$ votes on behalf of all voters\\
-- $\mathcal{Z}$ stops the vote-casting phase.\\
--  $B$ computes the election's tally and proof of the tally's correctness.\\
-- $\mathcal{Z}$ asks $\mathcal{G}_{BB}$ for the election result $\tau$\\
-- $\mathcal{Z}$ requests every voter to verify his ballot correctness.\\
-- $\mathcal{B}$ will run the verification on behalf of all voters using ballots and receipts from $\{b_0,r_0\}$.\\
-- $\mathcal{Z}$ outputs 1 or 0 depending on the voters' verdict.\\
--$\mathcal{B}$ outputs whatever the $\mathcal{Z}$ outputs.
\end{minipage}}\\\\
The challenger $\mathcal{C}$  outputs simulated ballot and receipt as $(b_0,r_0)$, when the coin $a=0$ and as $(b_1,r_1)$ otherwise.\\\\
In case when $a=0, \mathcal{B}$'s behaviour is identical to the $\mathcal{A}$'s strategy and $\mathcal{B}$ wins if $\mathcal{Z}$ outputs 0, which happens if at least one voter rejects the simulated receipt.  By assumption $\Pr[\exec_{\mathcal{Z},\mathcal{A}}^{\Pi, \mathcal{G}_{BB}} = 0] \geq  \beta$, where $\beta$ is non-negligible. Therefore if $(b_0,r_0)$ is the set of simulated ballot and receipt, $\mathcal{B}$ wins with the probability $Pr[\mathcal{B} \rightarrow 0| a=0] = \Pr[\exec_{\mathcal{Z},\mathcal{A}}^{\Pi, \mathcal{G}_{BB}}~=~0] \geq \beta$, where $\beta$ is non-negligible. \\\\
On the other hand, when $a=1$, $\mathcal{B}$ plays honestly and the probability of $\mathcal{Z}$ outputting 1 is equal to probability that all voters successfully verify their votes in the honest execution, which is happens with overwhelming probability $1-negl(\lambda)$.\\\\ 
The probability of $\mathcal{B}$  winning the attack against the strict privacy is \\$\Pr[G_{strict}^{\mathcal{B}}(1^{\lambda})=1]= \Pr[\mathcal{B} \rightarrow 0| a=0]\Pr[a=0] + \Pr[\mathcal{B} \rightarrow 1| a=1]\Pr[a=1] =  \Pr[\exec_{\mathcal{Z},\mathcal{A}}^{\Pi, \mathcal{G}_{BB}}=0]\Pr[a=0]  + \Pr[\exec_{\mathcal{Z},honest}^{\Pi, \mathcal{G}_{BB}} =1]\Pr[a=1] \geq \frac{1}{2}\beta+ \frac{1}{2} - negl(\lambda)$ , where $\beta$ is not negligible. This implies that $\mathcal{B}$ wins the attack against strict privacy with the probability more than $\frac{1}{2} + negl(\lambda)$, which contradicts the assumption that the $\Pi$ is strictly private.\\\\
In the Ideal Execution any simulator $S$ can either:\\
1) post in $\mathcal{G}_{BB}$ the tally $\tau'$ generated by $\mathcal{A}$ or any other tally  $\tau' \neq \tau$\\ 
or\\
2) ignore the $\mathcal{A}$'s tally and post the actual tally $\tau$.\\\\
In the first case, the ideal functionality for E2E verifiability  $\mathcal{F}$  would always detect the tally deviation caused by $\mathcal{A}$ if such exists. And since  $\mathcal{A}$ doesn't corrupt $\asd$s, for all honest voters the ideal functionality $\mathcal{F}$ would block verification responses. This implies that in the Ideal Execution $\exec_{\mathcal{Z}, \mathcal{S}}^{\mathcal{F}, \mathcal{G}_{BB}}$ $\mathcal{Z}$ would get no response from honest voters. The total number of successful verifications would be equal to the number of corrupted voters, which is less (if not voters are corrupted) than the total number of voters -- $\mathcal{Z}$ outputs 0.  \\\\
In the second case, there exists a class of simulators which ignore $\mathcal{A'}$ actions and post the actual tally.  For those simulators consider an modified  environment $\tilde{\mathcal{Z}}$ that works as follows:\\\\
\fbox{\begin{minipage}{33em}
$\tilde{\mathcal{Z}}$:\\
Outputs a bit according to the following rules:\\
$ \begin{cases}
 \text{if} ~~\mathcal{Z}~~ \text{outputs 1 and the number of non-blank votes greater or equal}~~ \gamma \text{-- output 1} \\ 
 \text{else output 0}
\end{cases}$
\end{minipage}}.
$\tilde{\mathcal{Z}}$ would still output 1 in case of the real execution since the number of non-blank votes would be at least $\gamma$ due to successful attack  $\mathcal{A}$. However  $\tilde{\mathcal{Z}}$ would not find at least $\gamma$ non-blank votes and output 0 in the ideal execution. \\\\
Thus, there is the attacker $\mathcal{A}$ such that for any simulator $\mathcal{S}$ there is the environment $\tilde{\mathcal{Z}}$ or $\mathcal{Z}$ which can always distinguish real and ideal executions. \\

\section{Proof part 2: E2E Verifiability vs Strict privacy with respect to $\vsd$ and $T$.}
Suppose there is a system $\Pi'$, which is strictly private in case ``$\ea$ is honest, but $\vsd$ is corrupted".\\
Consider the following attack against E2E Verifiability: \\
\fbox{\begin{minipage}{30em}
$\mathcal{A'}$:\\
-- corrupts $\ea$ and $\vsd$s but doesn't corrupt $\asd$s.\\
-- chooses an option $U_a \in \mathcal{U}$\\
-- corrupts $t$ voters $(t \leq n)$ , where $n$ is the total number of voters.\\ 
-- provides every honest voter $V_i$ with fake credentials $s_i'$ s.t. the ballot and receipt produced using $(s_i',`no~one')$ are identical to the ballot and receipt produced using real credentials for an option $U_a$: $b,r \leftarrow (s_i',`no~one') $ AND $ b,r \leftarrow (s_i,U_a)$\\
-- creates fake voters $\{V_0',V_1',\dots,V_n'\}$ and provides them with real credentials $s_i$\\
--  using its power substitutes some part $\gamma$ of honest voters' cast protocols with the fake voters' protocols for the $U_a$ option.
\end{minipage}}\\\\
let $\mathcal{Z'}$ be the environment that works as follows:\\\\
\fbox{\begin{minipage}{30em}
$\mathcal{Z'}$:\\
--  defines an election setup information:\\ $election\_params = (\mathcal{C},\mathcal{V}, \mathcal{U}, params)$, where $\mathcal{C}$ - list of candidates, $\mathcal{V}$ - list of voters, $\mathcal{U}$ - list of allowed candidates' selections, $params$ - other required information.\\
-- instructs each voter $V_i$ to vote for the blank option (`no~one').\\
-- stops the vote-casting phase.\\
-- asks $\mathcal{G}_{BB}$ for the election result $\tau$\\
--  asks every voter $V_i$ to verify his choice and return the result of verification - $response_i$, where $response_i$ equal to $(sid, verify\_responce, \tau')$  in case of successful verification and $\bot$ otherwise.\\
-- If the number of successful verification responses equal to the number of voters and in all responses provided by a voter tally $\tau'$ is equal to the $\mathcal{G}_{BB}$'s tally $\tau$ return 1. Otherwise return 0.
\end{minipage}}
\\\\
Since $\Pi'$ is strictly private, probability, that an adversary engaging in the \textbf{Registration} protocol would distinguish real and simulated view and win the attack against the strict privacy $|\Pr[G_{strict,\ea}^{\mathcal{A},Sim}(1^{\lambda},n,m) = 1] - \frac{1}{2}| = \alpha$ where $\alpha$ is negligible. In case ``$\ea$ is honest, but $\vsd$ is corrupted'', simulated view is credentials $\tilde{s_i}$ generated via the simulator $Sim$. \\\\
%%%%%
In the Real Execution a voter $V_i$ starts the Cast protocol using fake credentials $s_i'$ and an option $`no~one'$. However, $\mathcal{A'}$ substitutes his ballot and receipt with the ballot and receipt generated for a fake voter with real credentials and $U_a$ option. By nature of the attack, the returned receipt generated for real credentials and the $U_a$ option is identical to the receipt produced for a fake credentials and $`no~one'$ option. Therefore in the Real Execution $\mathcal{Z'}$ would output 1 if non of the voters would detect that he was given a receipt for fake credentials. The probability of this event is $\Pr[\exec_{\mathcal{Z'},\mathcal{A'}}^{\Pi', \mathcal{G}_{BB}} = 1] =  \Pr[all~V_i~accept] = \prod_{i=0}^n(1- \Pr[V_i~rejects] )$. Suppose, the probability of rejection by $V_i$ is $ \Pr[V_i~rejects] = \zeta$. Thus,   $\Pr[\exec_{\mathcal{Z'},\mathcal{A'}}^{\Pi', \mathcal{G}_{BB}} = 1] = (1 - \zeta)^n = 1 - n\zeta = 1- \zeta'$.\\\\
%%%%
Suppose that $ \zeta'$ is not negligible. This means that $\Pr[\exec_{\mathcal{Z'},\mathcal{A'}}^{\Pi', \mathcal{G}_{BB}} = 0] = 1 - \Pr[\exec_{\mathcal{Z'},\mathcal{A'}}^{\Pi', \mathcal{G}_{BB}} = 1] =  \zeta'$, where $ \zeta'$ is not negligible. This means that at least one voter rejects the receipt with a non-negligible probability. I will show that this contradicts the definition of strict privacy. Consider an attacker $\mathcal{B'}$ against strict privacy which exploits the environment  $\mathcal{Z'}$. \\\\
\begin{tikzpicture}
    \node (s) [a] {$\mathcal{C}$};
    \path (s.east)+(1.5*\blockdist,0) node (system) [draw, text width=8em, 
    text centered, minimum height=8em] {};
    \path (s.east)+(1.1*\blockdist,1) node (adv) [sensor] {$\ea$};
     \path (s.east)+(1.1*\blockdist,-0.5) node (ss) [sensor] {$\mathcal{Z'}$};
     \path (s.east) +(1.5*\blockdist, -1.3) node (ssimulator) {$\mathcal{B'}$};
    \draw[transform canvas={yshift=0.7ex},->] (system) -- (s);
    \draw[transform canvas={yshift=-0.7ex},<-] (system) -- (s);
\end{tikzpicture}\\\\
\fbox{\begin{minipage}{30em}
$\mathcal{B'}$ interacts with the challenger in the strict privacy attack  $\mathcal{C}$ as follows: \\
-- $\mathcal{Z}$ defines an election parameters  $election\_params$, assign each voter the blank option $\{V_i,`no~one'\}$ and send this information to the $\mathcal{B}$.\\
-- $\mathcal{B'}$ forwards received $election\_params$ to the $\mathcal{C}$. \\
-- $\mathcal{B'}$ corrupts the $\vsd$.\\
-- $\mathcal{C}$ starts the election.\\
-- $\mathcal{B'}$ sends  to $\mathcal{C}$ $(V_i,`no~one',U_a)$.\\
-- $\mathcal{C}$ sends back $s_0,s_1$. \\
--  $\mathcal{B'}$ provides voters with credentials $s_0$ and uses $(s_0,`no~one')$ to produce the ballot and receipt and posts the result on $\bb$.\\ 
-- $\mathcal{Z'}$ stops the vote-casting phase.\\
--  $\mathcal{C}$ executes the $Tally$ protocol.\\
-- $\mathcal{Z'}$ asks $\mathcal{G}_{BB}$ for the election result $\tau$\\
-- $\mathcal{Z'}$ requests every voter to verify his ballot correctness.\\
-- $\mathcal{B'}$ will run the verification on behalf of all voters.\\
-- $\mathcal{Z'}$ outputs 1 or 0 depending on the voters' verdict.\\
-- $\mathcal{B'}$ outputs whatever the $\mathcal{Z'}$  outputs.\\
\end{minipage}}\\\\
In case when the simulated credentials are chosen ($a=0$), $\mathcal{B'}$ provides a voter with fake credentials and generated ballot and receipt for the blank option using the fake credentials, which means that real credentials correspond to the $U_a$ option. $\mathcal{B'}$'s behaviour is identical to the $\mathcal{A'}$'s strategy. $\mathcal{B'}$ wins if outputs 0, which happens if  $\mathcal{Z'}$ outputs 0. $\Pr[\mathcal{B}'\rightarrow 0| a=0 ] = \Pr[\exec_{\mathcal{Z'},\mathcal{A'}}^{\Pi', \mathcal{G}_{BB}}=0] = \zeta'$\\\\
%
Else if $a=1$, $\mathcal{B'}$ provides a voter with real credentials and uses the real credentials to vote for the blank option, which is honest behaviour. $\Pr[B'\rightarrow 1| a=1] =\Pr[\exec_{\mathcal{Z'},honest}^{\Pi', \mathcal{G}_{BB}}=1] = 1$\\\\
%
Thus, the probability of $\mathcal{B'}$  winning the attack against the strict privacy is \\$\Pr[G_{strict,\ea}^{\mathcal{B}, Sim}(1^{\lambda})=1]= \frac{1}{2}(\Pr[B'\rightarrow 0| a=0] + \Pr[B'\rightarrow 1| a=1])  = \frac{1}{2} (\zeta' +1) =  \frac{1}{2}  +  \frac{1}{2} \zeta'$ , where $\zeta'$ is not negligible. This implies that $\mathcal{B'}$ wins the attack against strict privacy with the probability more than $\frac{1}{2} + negl(\lambda)$, which contradicts the assumption that the $\Pi$ is strictly private.\\\\
In the Ideal Execution any simulator $S$ can either:\\
1) post in $\mathcal{G}_{BB}$ the tally $\tau'$ generated by $\mathcal{A'}$ or any other tally  $\tau' \neq \tau$\\ 
or\\
2) ignore the $\mathcal{A'}$'s tally and post the actual tally $\tau$.\\\\
In the first case, the ideal functionality for E2E verifiability  $\mathcal{F}$  would always detect the tally deviation caused by $\mathcal{A'}$ if such exists. And since  $\mathcal{A'}$ doesn't corrupt $\asd$s, for all honest voters the ideal functionality $\mathcal{F}$ would block verification responses. This implies that in the Ideal Execution $\exec_{\mathcal{Z'}, \mathcal{S}}^{\mathcal{F}, \mathcal{G}_{BB}}$ $\mathcal{Z'}$ would get no response from honest voters. The total number of successful verifications would be equal to the number of corrupted voters, which is less (if not voters are corrupted) than the total number of voters -- $\mathcal{Z'}$ outputs 0.  \\\\
In the second case, there exists a class of simulators which ignore $\mathcal{A'}$ actions and post the actual tally.  For those simulators consider an modified  environment $\tilde{\mathcal{Z'}}$ that works as follows:\\
\fbox{\begin{minipage}{33em}
$\tilde{\mathcal{Z'}}$:\\
Outputs a bit according to the following rules:\\
$ \begin{cases}
 \text{if} ~~\mathcal{Z}~~ \text{outputs 1 and the number of non-blank votes greater or equal}~~ \gamma \text{-- output 1} \\ 
 \text{else output 0}
\end{cases}$
\end{minipage}}.
$\tilde{\mathcal{Z'}}$ would still output 1 in case of the real execution since the number of non-blank votes would be at least $\gamma$ due to successful attack  $\mathcal{A}$. However  $\tilde{\mathcal{Z'}}$ would not find at least $\gamma$ non-blank votes and output 0 in the ideal execution. \\\\
Thus, there is the attacker $\mathcal{A'}$ such that for any simulator $\mathcal{S}$ there is the environment $\tilde{\mathcal{Z'}}$ or $\mathcal{Z'}$ which can always distinguish real and ideal executions. 